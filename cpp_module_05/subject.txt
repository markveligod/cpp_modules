Глава I
Общий порядок
• Любая функция, реализованная в заголовке (за исключением шаблонов), и любой незащищенный заголовок означают 0 для упражнения.
• Каждый вывод переходит в стандартный вывод и заканчивается новой строкой, если не указано иное.
• За введенными именами файлов необходимо следовать до буквы, а также за именами классов, функций и методов.
• Помните: теперь вы кодируете на C++, а не на C больше. Следовательно:
    ◦ Следующие функции запрещены, и их использование будет наказано 0, без вопросов: *alloc, *printf и free.
    ◦ Вы можете использовать практически все, что есть в стандартной библиотеке. Однако было бы разумно попробовать использовать C++-версии функций, к которым вы привыкли в C, вместо того чтобы просто придерживаться того, что вы знаете, в конце концов, это новый язык. И нет, вам не разрешается использовать STL, пока вы на самом деле не должны это делать (то есть до модуля 08). Это означает, что нет векторов/списков/карт/и т. д... или все, что требует включения <алгоритма> до тех пор.
• На самом деле, использование любой явно запрещенной функции или механики будет наказываться 0, никаких вопросов не задавалось.
• Также обратите внимание, что если не указано иное, ключевые слова C++ "using namespace" и "friend" запрещены. Их использование будет наказано а-42, никаких вопросов.
• Файлы, связанные с классом, всегда будут иметь значение "ClassName.hpp" и "ClassName.cpp", если не указано иное.
• Turn-in directories are ex00/, ex01/, . . . , exn/.
• Вы должны внимательно прочитать примеры. Они могут содержать требования, которые не очевидны в описании упражнения. Если что-то кажется двусмысленным, вы недостаточно понимаете C++.
• Поскольку вам разрешено использовать инструменты C++, о которых вы узнали с самого начала, вы не можете использовать какую-либо внешнюю библиотеку. И прежде чем вы спросите, это также означает, что нет C++11 и производных, ни Boost, ни чего-то еще, без чего ваш потрясающе опытный друг сказал вам, что C++ не может существовать.
• От вас может потребоваться сдать значительное количество классов. Это может показаться утомительным, если вы не можете написать сценарий своего любимого текстового редактора.
• Прочитайте каждое упражнение полностью, прежде чем начать его! Действительно сделать это.
• The compiler to use is clang++.
• Your code has to be compiled with the following flags : -Wall -Wextra -Werror.
• Каждый из ваших включений должен быть способен включаться независимо от других. Обязательные содержит все остальные входят они в зависимости от того, очевидно.
• На случай, если вам интересно, никакой стиль кодирования не применяется во время работы в C++. Вы можете использовать любой стиль, который вам нравится, без ограничений. Но помните, что код, который ваш эксперт не может прочитать,-это код, который он или она не могут оценить.
• Теперь важный момент : Вы не будете оцениваться программой, если только это не будет прямо указано в предмете. Поэтому вам предоставляется определенная свобода в том, как вы решите выполнять упражнения. Однако помните об ограничениях каждого упражнения, и не ленитесь, вы упустите многое из того, что они могут предложить !
• Это не проблема иметь некоторые посторонние файлы в том, что вы включаете, вы можете выбрать, чтобы разделить ваш код в большем количестве файлов, чем то, что от вас требуется. Не стесняйтесь, так как до тех пор, пока результат не будет оценен программой.
• Даже если тема упражнения коротка, стоит потратить на нее некоторое время, чтобы быть абсолютно уверенным, что вы понимаете, чего от вас ждут, и что вы сделали это наилучшим образом.
____________________________________________________________________________________________________________________________
Exercise 00: Mommy, when I growup, I want to be a bureaucrat!

Turn-in directory : ex00/
iles to turn in : Bureaucrat.hpp Bureaucrat.cpp main.cpp
Forbidden functions :None

Сегодня мы создадим искусственный кошмар из офисов, коридоров, форм и ожидания в очереди. Звучит весело? - Нет? Очень жаль.

Во-первых, мы начинаем с самого маленького винтика в огромной бюрократической машине: Bureaucrat

Он должен иметь постоянное имя и grade, который колеблется от 1 (Максимально возможный) до 150 (минимально возможный). Любая попытка создать Bureaucrat с недопустимым классом должна вызвать исключение, которое будет либо Bureaucrat::GradeTooHighException или Bureaucrat::GradeTooLowException

Вы предоставите геттеры для обоих этих атрибутов (getName и getGrade), а также две функции для увеличения или уменьшения оценки. Обе эти функции будут выдавать те же исключения, что и раньше, если оценка становится слишком высокой или слишком низкой. Помните, что класс 1-самый высокий,150-самый низкий, поэтому увеличение класса 3 дает вам класс 2...

Исключения, которые вы бросаете, должны быть уловимы блоком типа:
try
{
    /* do some stuff with bureaucrats */
}
catch(std::exception & e)
{
    /* handle exception */
}

Вам будет предоставлен перегрузка оператора<< потока, который выводит что-то вроде: 
<name>, bureaucrat grade <grade>.
Конечно, вы предоставите основную функцию, чтобы доказать, что вы сделали все это хорошо.
____________________________________________________________________________________________________________________________
Exercise 01: Form up, maggots!

Turn-in directory : ex01/
Files to turn in : Same as before + Form.cpp Form.hpp
Forbidden functions : None

Теперь, когда у нас есть бюрократы, лучше дать им что-то делать со своим временем.Что может быть лучше, чем заполнять стопку бланков?

Создайте класс Form. У него есть имя, логическое значение, указывающее, подписано ли оно (в начале, это не так), оценка, необходимая для его подписания, и оценка, необходимая для его выполнения. Имя и оценки являются постоянными, и все эти атрибуты являются частными (не защищенными).Оценки подчиняются тем же ограничениям, что и в Bureaucrat,и исключения будут выброшены, если какой-либо из них находится за пределами границ, Form::GradeTooHighException и Form::GradeTooLowException.

Как и раньше, сделайте геттеры для всех атрибутов и перегрузку оператора <<ostream, который полностью описывает состояние формы.

Вы также добавите функцию beSigned, которая принимает бюрократа и делает формы подписанными, если оценка бюрократа достаточно высока. Всегда помните, что класс 1 лучше, чем класс 2. Если оценка слишком низкая, выбросьте исключение Form::GradeTooLowException.

Также добавьте функцию signForm в класс Bureaucrat. Если подпись успешна, то напечатайте что-то вроде: "<bureaucrat> signs <form>" в противном случае напечайте что-то вроде: "<bureaucrat> cannot sign <form> because <reason>".

Добавьте необходимое количество тестов в ваш main.
____________________________________________________________________________________________________________________________
Exercise 02: No, you need form 28B,not 28C...

Turn-in directory :ex02/
Files to turn in :Same as before + ShrubberyCreationForm.[hpp,cpp]RobotomyRequestForm.[hpp,cpp] PresidentialPardonForm.[hpp,cpp]
Forbidden functions :None

Теперь, когда у вас есть основные формы, вы сделаете несколько форм, которые действительно что-то делают
Create a few concrete forms:
• ShrubberyCreationForm (Required grades: sign 145, exec 137): Action: Создайте файл с именем <target>_shrubbery, и оставить деревья в формате ASCII, внутри него, в текущей директории.
• RobotomyRequestForm (Required grades: sign 72, exec 45). Action: издает какие-то сверлящие звуки и сообщает нам, что <target> была успешно роботомирована в 50% случаев. В противном случае, скажите нам, что это провал.
• PresidentialPardonForm (Required grades: sign 25, exec 5). Action: Говорит нам, что <target> была помилована Зафодом Библброксом.
Все они должны будут принимать только один параметр в своем конструкторе, который будет представлять цель формы. Например, "home", если вы хотите посадить кустарник у себя дома. Помните, что атрибуты формы должны оставаться закрытыми и находиться в базовом классе.

Теперь вам нужно добавить метод execute(Bureaucrat const & executor) const к базовой форме и реализовать метод, фактически выполняющий действие формы во всех конкретных формах. Вы должны проверить, что форма подписана, и что бюрократ, пытающийся выполнить форму, имеет достаточно высокую оценку, иначе вы бросите соответствующее исключение. Хотите ли вы сделать эти проверки в каждом конкретном классе или сделать проверку в базовом классе, а затем вызвать другой метод для фактического выполнения действия, зависит от вас, но один способ, очевидно, красивее другого. В любом случае базовая форма должна быть абстрактным классом.

Завершите это, добавив executeForm(Form const & form) функцию для бюрократа. Он должен попытаться выполнить форму, и если это удастся, напечатать что-то вроде  "<bureaucrat> executes <form>.". Если нет, выведите явное сообщение об ошибке.

Добавьте все, что вам нужно, к вашему main, чтобы проверить, что все работает.
____________________________________________________________________________________________________________________________
Exercise 03: At least this beatscoffee-making

Turn-in directory : ex03/
Files to turn in : Same as before + Intern.hpp Intern.cpp
Forbidden functions : None

Поскольку заполнение форм достаточно раздражает, было бы просто жестоко просить наших бюрократов писать их полностью самостоятельно. Нет, мы просто попросим стажера сделать это.

Вы собираетесь создать Intern класс. У Intern нет ни имени, ни звания, ни каких-либо определяющих характеристик, мы заботимся только о том, чтобы он выполнял свою работу.

У стажера есть одна важная вещь-функция makeForm. Он принимает две строки, первая из которых представляет имя формы, а вторая-цель для формы. Он возвращает в качестве указателя на форму указатель на любой конкретный класс формы, представленный первым параметром, инициализированным вторым параметром. Он напечатает что-то вроде "Intern creates <form>" к стандартному выходу. Если он использует худший метод, например ветвления elseif/elseif/elseif/else, или какие-то другие уродливые вещи, подобные этому, он не будет принят во время оценки. Если запрошенная форма неизвестна, выведите явное сообщение об ошибке.
For example, this would create a RobotomyRequestForm targeted on"Bender":
{
    Intern  someRandomIntern;
    Form*   rrf;
    
    rrf = someRandomIntern.makeForm("robotomy request", "Bender");
}
Your main must, of course, test all of this
