Глава I
Общий порядок
• Любая функция, реализованная в заголовке (за исключением шаблонов), и любой незащищенный заголовок означают 0 для упражнения.
• Каждый вывод переходит в стандартный вывод и заканчивается новой строкой, если не указано иное.
• За введенными именами файлов необходимо следовать до буквы, а также за именами классов, функций и методов.
• Помните: теперь вы кодируете на C++, а не на C больше. Следовательно:
    ◦ Следующие функции запрещены, и их использование будет наказано 0, без вопросов: *alloc, *printf и free.
    ◦ Вы можете использовать практически все, что есть в стандартной библиотеке. Однако было бы разумно попробовать использовать C++-версии функций, к которым вы привыкли в C, вместо того чтобы просто придерживаться того, что вы знаете, в конце концов, это новый язык. И нет, вам не разрешается использовать STL, пока вы на самом деле не должны это делать (то есть до модуля 08). Это означает, что нет векторов/списков/карт/и т. д... или все, что требует включения <алгоритма> до тех пор.
• На самом деле, использование любой явно запрещенной функции или механики будет наказываться 0, никаких вопросов не задавалось.
• Также обратите внимание, что если не указано иное, ключевые слова C++ "using namespace" и "friend" запрещены. Их использование будет наказано а-42, никаких вопросов.
• Файлы, связанные с классом, всегда будут иметь значение "ClassName.hpp" и "ClassName.cpp", если не указано иное.
• Turn-in directories are ex00/, ex01/, . . . , exn/.
• Вы должны внимательно прочитать примеры. Они могут содержать требования, которые не очевидны в описании упражнения. Если что-то кажется двусмысленным, вы недостаточно понимаете C++.
• Поскольку вам разрешено использовать инструменты C++, о которых вы узнали с самого начала, вы не можете использовать какую-либо внешнюю библиотеку. И прежде чем вы спросите, это также означает, что нет C++11 и производных, ни Boost, ни чего-то еще, без чего ваш потрясающе опытный друг сказал вам, что C++ не может существовать.
• От вас может потребоваться сдать значительное количество классов. Это может показаться утомительным, если вы не можете написать сценарий своего любимого текстового редактора.
• Прочитайте каждое упражнение полностью, прежде чем начать его! Действительно сделать это.
• The compiler to use is clang++.
• Your code has to be compiled with the following flags : -Wall -Wextra -Werror.
• Каждый из ваших включений должен быть способен включаться независимо от других. Обязательные содержит все остальные входят они в зависимости от того, очевидно.
• На случай, если вам интересно, никакой стиль кодирования не применяется во время работы в C++. Вы можете использовать любой стиль, который вам нравится, без ограничений. Но помните, что код, который ваш эксперт не может прочитать,-это код, который он или она не могут оценить.
• Теперь важный момент : Вы не будете оцениваться программой, если только это не будет прямо указано в предмете. Поэтому вам предоставляется определенная свобода в том, как вы решите выполнять упражнения. Однако помните об ограничениях каждого упражнения, и не ленитесь, вы упустите многое из того, что они могут предложить !
• Это не проблема иметь некоторые посторонние файлы в том, что вы включаете, вы можете выбрать, чтобы разделить ваш код в большем количестве файлов, чем то, что от вас требуется. Не стесняйтесь, так как до тех пор, пока результат не будет оценен программой.
• Даже если тема упражнения коротка, стоит потратить на нее некоторое время, чтобы быть абсолютно уверенным, что вы понимаете, чего от вас ждут, и что вы сделали это наилучшим образом.
____________________________________________________________________________________________________________________________
Exercise 00: A few functions

Turn-in directory : ex00/
Files to turn in : whatever.cpp and a Makefile
Allowed functions : None

Напишите следующие шаблоны функций:
swap: Свапните значения двух аргументов. Ничего не возвращайте.
min: Сравните два аргумента и верните наименьшее из них. Если два аргумента равны, тогда верните второй из них.
max: Сравните два аргумента и верните наибольшее из них. Если два аргумента равны, тогда верните второй из них.

Эти функции могут быть вызваны с любыми типами аргументов, с условием, что два аргумента имеют один и тот же тип и поддерживают все операторы сравнения. Обеспечите достаточным кодом для компиляции и исполнения чтобы доказать что все работает как предназначено.

int main(void) 
{
    int a = 2;
    int b = 3;
    
    ::swap( a, b );
    std::cout << "a = " << a << ", b = " << b << std::endl;
    std::cout << "min( a, b ) = " << ::min( a, b ) << std::endl;
    std::cout << "max( a, b ) = " << ::max( a, b ) << std::endl;
    
    std::string c = "chaine1";
    std::string d = "chaine2";
    
    ::swap(c, d);
    std::cout << "c = " << c << ", d = " << d << std::endl;
    std::cout << "min( c, d ) = " << ::min( c, d ) << std::endl;
    std::cout << "max( c, d ) = " << ::max( c, d ) << std::endl;
    return 0;
}

Should output the following if you did well:
a = 3, b = 2
min(a, b) = 2
max(a, b) = 3
c = chaine2, d = chaine1
min(c, d) = chaine1
max(c, d) = chaine2
____________________________________________________________________________________________________________________________
Exercise 01: Iter

Turn-in directory : ex01/
Files to turn in : iter.cpp and a Makefile
Allowed functions : None

Напишите шаблон функции iter которая принимает 3 параметра и возвращает ничего. Первый параметр адресс на массив, второй размер массива и третий функция которая вызывается на каждый элемент массива.

Оберните свою работу в исполняемый файл, который доказывает, что ваш шаблон функции работает с любым типом массива и/или с экземпляром шаблона функции в качестве третьего параметра.
____________________________________________________________________________________________________________________________
Exercise 02: Array

Turn-in directory : ex02/
Files to turn in : Array.hpp, or Array.tpp, or Array.h, or anything that makessens, plus anything necessary to build an executable, and a Makefile
Allowed functions : None

Напишите класс шаблона Array который содержит элементы типа T и который допускает следующее поведение:
    • Конструктор без параметров: создает пустой массив.
    • Конструктор с параметром "unsigned int n": создает массив n элементов, иницилизирует по дефолту. (Совет: попытайтесь скомпилировать "int * a = new int();" затем отобразить "*a")
    • Конструктор копирования и оператор присваивания. В обоих случаях изменение одного из двух массивов после копирования/присвоения не повлияет ни на что в другом массиве.
    • Вы должны использовать оператор new[] для вашей аллокации. Вы не должны делать превентивные выделения. Ваш код никогда не должен обращаться к не выделенной памяти.
    • Элементы доступны через operator[].
    • При обращении к элементу с помощью operator[], если этот элемент выходит за пределы выкиньте std::exception
    • Размер члена функций, которая возвращает количество элементов в массиве. Эта функция не принимает никаких параметров и никоим образом не изменяет текущий экземпляр.

Оберните свою работу в исполняемый файл, который докажет, что ваш шаблон класса работает так, как задумано.
____________________________________________________________________________________________________________________________