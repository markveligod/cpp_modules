Глава I
Общий порядок
• Любая функция, реализованная в заголовке (за исключением шаблонов), и любой незащищенный заголовок означают 0 для упражнения.
• Каждый вывод переходит в стандартный вывод и заканчивается новой строкой, если не указано иное.
• За введенными именами файлов необходимо следовать до буквы, а также за именами классов, функций и методов.
• Помните: теперь вы кодируете на C++, а не на C больше. Следовательно:
    ◦ Следующие функции запрещены, и их использование будет наказано 0, без вопросов: *alloc, *printf и free.
    ◦ Вы можете использовать практически все, что есть в стандартной библиотеке. Однако было бы разумно попробовать использовать C++-версии функций, к которым вы привыкли в C, вместо того чтобы просто придерживаться того, что вы знаете, в конце концов, это новый язык. И нет, вам не разрешается использовать STL, пока вы на самом деле не должны это делать (то есть до модуля 08). Это означает, что нет векторов/списков/карт/и т. д... или все, что требует включения <алгоритма> до тех пор.
• На самом деле, использование любой явно запрещенной функции или механики будет наказываться 0, никаких вопросов не задавалось.
• Также обратите внимание, что если не указано иное, ключевые слова C++ "using namespace" и "friend" запрещены. Их использование будет наказано а-42, никаких вопросов.
• Файлы, связанные с классом, всегда будут иметь значение "ClassName.hpp" и "ClassName.cpp", если не указано иное.
• Turn-in directories are ex00/, ex01/, . . . , exn/.
• Вы должны внимательно прочитать примеры. Они могут содержать требования, которые не очевидны в описании упражнения. Если что-то кажется двусмысленным, вы недостаточно понимаете C++.
• Поскольку вам разрешено использовать инструменты C++, о которых вы узнали с самого начала, вы не можете использовать какую-либо внешнюю библиотеку. И прежде чем вы спросите, это также означает, что нет C++11 и производных, ни Boost, ни чего-то еще, без чего ваш потрясающе опытный друг сказал вам, что C++ не может существовать.
• От вас может потребоваться сдать значительное количество классов. Это может показаться утомительным, если вы не можете написать сценарий своего любимого текстового редактора.
• Прочитайте каждое упражнение полностью, прежде чем начать его! Действительно сделать это.
• The compiler to use is clang++.
• Your code has to be compiled with the following flags : -Wall -Wextra -Werror.
• Каждый из ваших включений должен быть способен включаться независимо от других. Обязательные содержит все остальные входят они в зависимости от того, очевидно.
• На случай, если вам интересно, никакой стиль кодирования не применяется во время работы в C++. Вы можете использовать любой стиль, который вам нравится, без ограничений. Но помните, что код, который ваш эксперт не может прочитать,-это код, который он или она не могут оценить.
• Теперь важный момент : Вы не будете оцениваться программой, если только это не будет прямо указано в предмете. Поэтому вам предоставляется определенная свобода в том, как вы решите выполнять упражнения. Однако помните об ограничениях каждого упражнения, и не ленитесь, вы упустите многое из того, что они могут предложить !
• Это не проблема иметь некоторые посторонние файлы в том, что вы включаете, вы можете выбрать, чтобы разделить ваш код в большем количестве файлов, чем то, что от вас требуется. Не стесняйтесь, так как до тех пор, пока результат не будет оценен программой.
• Даже если тема упражнения коротка, стоит потратить на нее некоторое время, чтобы быть абсолютно уверенным, что вы понимаете, чего от вас ждут, и что вы сделали это наилучшим образом.
____________________________________________________________________________________________________________________________
Глава 2
Бонус правила
• Отныне каждый класс, который вы пишете, должен быть в канонической (Коплиенской) форме: по крайней мере один конструктор по умолчанию, конструктор копирования, перегрузка оператора назначения и adestructor. Мы больше не будем спрашивать.
____________________________________________________________________________________________________________________________
Глава 3
Exercise 00: My First Canonical Class

Turn-in directory :ex00/
Files to turn in : Fixed.class.hpp and Fixed.class.cpp, or Fixed.hpp and Fixed.cpp, or Fixed.h and Fixed.cc.  Pick one, I don’t care unless it’s stupid.
Forbidden functions :None

Вы знаете целые числа, а также числа с плавающей запятой. Как мило.

Пожалуйста, прочтите эту 3-страничную статью (1, 2, 3), чтобы обнаружить, что с вами не так. Давай, читай.

До сегодняшнего дня любые числа, которые вы использовали в своих программах, были в основном целыми числами или числами с плавающей запятой,или любыми их вариантами (short,char,long, double и т. д.). Из вашего предварительного чтения можно с уверенностью предположить, что целые числа и числа с плавающей запятой имеют противоположные характеристики.

Но сегодня все изменится. Вы откроете для себя новый и удивительный тип чисел: числа с фиксированной точкой! Всегда отсутствующие в большинстве языков скалярные типы, фиксированные точечные числа предлагают ценный баланс между производительностью, точностью, диапазоном и точностью, что объясняет, почему эти числа широко используются в графике, звуке или научном программировании.

Поскольку в C++отсутствуют числа с фиксированной точкой, вы собираетесь добавить их сами сегодня. Для начала я бы рекомендовал эту статью из Беркли. Если это хорошо для них, то хорошо и для тебя. Если вы понятия не имеете, что такое Беркли, прочтите этот раздел их страницы в Википедии

Напишите канонический класс для представления чисел с фиксированной точкой

• Private members:
    ◦ Целое число для хранения значения фиксированной точки.
    ◦ Целое число "статическая константа" для хранения количества дробных битов. Эта константа всегда будет литерал 8
• Public members:
    ◦ Конструктор по умолчанию, который инициализирует значение фиксированной точки равным 0.
    ◦ A destructor.
    ◦ A copy constructor.
    ◦ Перегрузка оператора назначения.
    ◦ Функция-член int getRawBits( void ) const;которая возвращает исходное значение значения фиксированной точки.
    ◦ Функция-член void setRawBits( int const row );которая устанавливает исходное значение значения фиксированной точки.
____________________________________________________________________________________________________________________________
