Глава I
Общий порядок
• Любая функция, реализованная в заголовке (за исключением шаблонов), и любой незащищенный заголовок означают 0 для упражнения.
• Каждый вывод переходит в стандартный вывод и заканчивается новой строкой, если не указано иное.
• За введенными именами файлов необходимо следовать до буквы, а также за именами классов, функций и методов.
• Помните: теперь вы кодируете на C++, а не на C больше. Следовательно:
    ◦ Следующие функции запрещены, и их использование будет наказано 0, без вопросов: *alloc, *printf и free.
    ◦ Вы можете использовать практически все, что есть в стандартной библиотеке. Однако было бы разумно попробовать использовать C++-версии функций, к которым вы привыкли в C, вместо того чтобы просто придерживаться того, что вы знаете, в конце концов, это новый язык. И нет, вам не разрешается использовать STL, пока вы на самом деле не должны это делать (то есть до модуля 08). Это означает, что нет векторов/списков/карт/и т. д... или все, что требует включения <алгоритма> до тех пор.
• На самом деле, использование любой явно запрещенной функции или механики будет наказываться 0, никаких вопросов не задавалось.
• Также обратите внимание, что если не указано иное, ключевые слова C++ "using namespace" и "friend" запрещены. Их использование будет наказано а-42, никаких вопросов.
• Файлы, связанные с классом, всегда будут иметь значение "ClassName.hpp" и "ClassName.cpp", если не указано иное.
• Turn-in directories are ex00/, ex01/, . . . , exn/.
• Вы должны внимательно прочитать примеры. Они могут содержать требования, которые не очевидны в описании упражнения. Если что-то кажется двусмысленным, вы недостаточно понимаете C++.
• Поскольку вам разрешено использовать инструменты C++, о которых вы узнали с самого начала, вы не можете использовать какую-либо внешнюю библиотеку. И прежде чем вы спросите, это также означает, что нет C++11 и производных, ни Boost, ни чего-то еще, без чего ваш потрясающе опытный друг сказал вам, что C++ не может существовать.
• От вас может потребоваться сдать значительное количество классов. Это может показаться утомительным, если вы не можете написать сценарий своего любимого текстового редактора.
• Прочитайте каждое упражнение полностью, прежде чем начать его! Действительно сделать это.
• The compiler to use is clang++.
• Your code has to be compiled with the following flags : -Wall -Wextra -Werror.
• Каждый из ваших включений должен быть способен включаться независимо от других. Обязательные содержит все остальные входят они в зависимости от того, очевидно.
• На случай, если вам интересно, никакой стиль кодирования не применяется во время работы в C++. Вы можете использовать любой стиль, который вам нравится, без ограничений. Но помните, что код, который ваш эксперт не может прочитать,-это код, который он или она не могут оценить.
• Теперь важный момент : Вы не будете оцениваться программой, если только это не будет прямо указано в предмете. Поэтому вам предоставляется определенная свобода в том, как вы решите выполнять упражнения. Однако помните об ограничениях каждого упражнения, и не ленитесь, вы упустите многое из того, что они могут предложить !
• Это не проблема иметь некоторые посторонние файлы в том, что вы включаете, вы можете выбрать, чтобы разделить ваш код в большем количестве файлов, чем то, что от вас требуется. Не стесняйтесь, так как до тех пор, пока результат не будет оценен программой.
• Даже если тема упражнения коротка, стоит потратить на нее некоторое время, чтобы быть абсолютно уверенным, что вы понимаете, чего от вас ждут, и что вы сделали это наилучшим образом.
____________________________________________________________________________________________________________________________
глава II
Упражнение 00: куча четвероногих

Exercise 00: Heap of quadrupeds
Turn-in directory : ex00/
Files to turn in : Pony.cpp Pony.hpp main.cpp
Forbidden functions : None

Начать с простого.
Составьте "класс пони", содержащий все, что, по вашему мнению, адекватно описывает пони. Затем создайте две функции, "ponyOnTheHeap" и "ponyOnTheStack", в которых вы будете выделять "пони" и заставлять его делать некоторые вещи.
Конечно, в первом случае пони должен быть помещен в кучу, а во втором - в стек.
Вы предоставите main достаточно кода, чтобы доказать, что то, что вы сделали, работает так, как задумано.
В обоих случаях "Pony" объекты не должны существовать после того, как функция отключит управление. (Ваш главный тоже должен будет продемонстрировать это во время коррекции!)
____________________________________________________________________________________________________________________________
Chapter III
Exercise 01 : Plumbing problem

Turn-in directory : ex01/
Files to turn in : ex01.cpp
Forbidden functions : None

Опять же, простое упражнение.
Вы должны включить следующую функцию, исправив содержащуюся в ней утечку памяти.
Конечно, вы должны играть с выделением/освобождением памяти здесь. Простое удаление переменной или иное манипулирование проблемой, фактически не разбирая ее, будет считаться неправильным ответом.
void memoryLeak()
{
    std::string* panthere = new std::string("String panthere");
    std::cout << *panthere << std::endl;
}
____________________________________________________________________________________________________________________________
Chapter IV
Exercise 02 : Plucking some brains

Turn-in directory : ex02/
Files to turn in : Zombie.cpp Zombie.hpp ZombieEvent.cpp ZombieEvent.hpp main.cpp
Forbidden functions : None

Во-первых, сделайте класс зомби. Сделайте так, чтобы он содержал тип и имя (по крайней мере), а также добавьте функцию - член announce(), которая будет выводить что-то вроде :
<name (type)> Braiiiiiiinnnssss...
Все, что вы хотите, на самом деле, пока вы выводите имя и тип зомби.
После этого вы создадите класс "ZombieEvent". Он будет иметь функцию "setZombieType", которая будет хранить тип в объекте, и функцию "Zombie* newZombie(std::stringname)", которая создаст зомби с выбранным типом, назовет его и вернет.
Вы также создадите функцию "randomChump", которая создаст "Zombie" со случайным именем и заставит его "announce" о себе. Какой бы "random" метод вы ни выбрали, действительно случайные имена или случайный выбор из пула имен, это прекрасно.
Вы должны включить полную программу, включая основную, с достаточным количеством доказательств того, что то, что вы сделали, работает так, как требуется. Например, сделайте так, чтобы ваши вновь созданные зомби объявили о себе.
Теперь реальный смысл упражнения : ваши зомби должны быть уничтожены в соответствующее время (так, когда они больше не нужны). Они также должны быть распределены соответствующим образом : в некоторых случаях уместно иметь их в стеке, в других случаях куча является лучшим выбором. Вам придется оправдать то, что вы сделали, чтобы получить положительную оценку.
____________________________________________________________________________________________________________________________
Chapter V
Exercise 03 : Moar brainz !

Turn-in directory : ex03/
Files to turn in : Zombie.cpp Zombie.hpp ZombieHorde.cpp ZombieHorde.hpp main.cpp
Forbidden functions : None

Повторно используя класс зомби, который вы сделали в предыдущем упражнении, создайте "ZombieHorde" класс.
Этот класс будет иметь конструктор, который принимает целое число N. При создании он должен выделить N зомби-объектов со случайными именами (то же понятие "random", что и раньше) и сохранить их. Затем он будет иметь функцию announce(), которая вызывает функцию announce() для каждого из содержащихся в ней объектов зомби.
Вы должны распределить все зомби-объекты в одном выделении и освободить их, когда ZombieHorde будет уничтожена.
Как обычно, снабдите main тестами и обоснуйте свой выбор.
____________________________________________________________________________________________________________________________
Chapter VI
Exercise 04 : HI THIS IS BRAIN

Turn-in directory : ex04/
Files to turn in : ex04.cpp
Forbidden functions : None

Сделайте программу, в которой вы создадите строку, содержащую "HI THIS IS BRAIN", указатель на нее и ссылку на нее.
Затем вы будете отображать его с помощью указателя и, наконец, отображать его с помощью ссылки.
Вот и все, никаких фокусов.
____________________________________________________________________________________________________________________________
Chapter VII
Exercise 05 : HI BRAIN THIS IS HUMAN

Turn-in directory : ex05/
Files to turn in : Brain.cpp Brain.hpp Human.cpp Human.hpp main.cpp
Forbidden functions : None

Создайте класс мозга, с тем, что вы считаете подходящим для мозга. Он будет иметь функцию identify (), которая возвращает строку, содержащую адрес мозга в памяти, в шестнадцатеричном формате, с префиксом 0x (например, "0x194F87EA").
Затем создайте человеческий класс, который имеет постоянный атрибут мозга, с тем же временем жизни. У него есть функция identify (), которая просто вызывает функцию identify() своего мозга и возвращает ее результат.
Теперь сделайте так, чтобы этот код компилировался и отображал два одинаковых адреса :

int main()
{
    Human bob;
    std::cout << bob.identify() << std::endl;
    std::cout << bob.getBrain().identify() << std::endl;
}

Этот код должен быть включен в качестве основного, и все, что вы добавляете к классам Human или Brain, чтобы заставить его работать, должно быть оправдано (с другим аргументом, чем "Er, yeah, well, i fiddled with it until it worked").
____________________________________________________________________________________________________________________________
Chapter VIII
Exercise 06 : Unnecessary violence

Turn-in directory : ex06/
Files to turn in : Weapon.cpp Weapon.hpp HumanA.cpp HumanA.hpp HumanB.cpp HumanB.hpp main.cpp
Forbidden functions : None

Создайте класс Weapon, который имеет тип string, и getType, который возвращает ссылку const на эту строку. Также имеет setType.
Теперь создайте два класса, HumanA и Humana, которые оба имеют Weapon, имя и функцию attack(), которая отображает что-то вроде: NAME attacks with his WEAPON_TYPE

Сделайте так, чтобы следующий код производил атаки с помощью "crude spiked club", а затем "some other type of club", в обоих тестовых случаях:

int main()
{
    {
        Weapon club = Weapon("crude spiked club");
        HumanA bob("Bob", club);
        bob.attack();
        club.setType("some other type of club");
        bob.attack();
    }
    {
        Weapon club = Weapon("crude spiked club");
        HumanB jim("Jim");
        jim.setWeapon(club);
        jim.attack();
        club.setType("some other type of club");
        jim.attack();
    }
}

В каком случае уместно хранить оружие в качестве указки ? В качестве ссылки ? Почему? Является ли это лучшим выбором в свете того, что спрашивается ? Вот вопросы, которые вы должны задать себе перед выполнением этого упражнения.
____________________________________________________________________________________________________________________________
Chapter IX
Exercise 07 : Sed is for losers

Turn-in directory : ex07/
Files to turn in : Makefile, and whatever else you need
Forbidden functions : None

Сделайте программу под названием replace, которая принимает имя файла и две строки, назовем их s1 и s2, которые не являются пустыми.
Он откроет файл и запишет его содержимое в файл FILENAME.replace, заменив каждое вхождение s1 на s2.
Конечно, вы будете обрабатывать ошибки как можно лучше и не использовать функции манипулирования файлами C, потому что это было бы мошенничеством, а мошенничество-это плохо, м'Кей?
Вы включите некоторые тестовые файлы, чтобы показать работу вашей программы.
____________________________________________________________________________________________________________________________