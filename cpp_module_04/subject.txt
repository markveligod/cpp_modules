Глава I
Общий порядок
• Любая функция, реализованная в заголовке (за исключением шаблонов), и любой незащищенный заголовок означают 0 для упражнения.
• Каждый вывод переходит в стандартный вывод и заканчивается новой строкой, если не указано иное.
• За введенными именами файлов необходимо следовать до буквы, а также за именами классов, функций и методов.
• Помните: теперь вы кодируете на C++, а не на C больше. Следовательно:
    ◦ Следующие функции запрещены, и их использование будет наказано 0, без вопросов: *alloc, *printf и free.
    ◦ Вы можете использовать практически все, что есть в стандартной библиотеке. Однако было бы разумно попробовать использовать C++-версии функций, к которым вы привыкли в C, вместо того чтобы просто придерживаться того, что вы знаете, в конце концов, это новый язык. И нет, вам не разрешается использовать STL, пока вы на самом деле не должны это делать (то есть до модуля 08). Это означает, что нет векторов/списков/карт/и т. д... или все, что требует включения <алгоритма> до тех пор.
• На самом деле, использование любой явно запрещенной функции или механики будет наказываться 0, никаких вопросов не задавалось.
• Также обратите внимание, что если не указано иное, ключевые слова C++ "using namespace" и "friend" запрещены. Их использование будет наказано а-42, никаких вопросов.
• Файлы, связанные с классом, всегда будут иметь значение "ClassName.hpp" и "ClassName.cpp", если не указано иное.
• Turn-in directories are ex00/, ex01/, . . . , exn/.
• Вы должны внимательно прочитать примеры. Они могут содержать требования, которые не очевидны в описании упражнения. Если что-то кажется двусмысленным, вы недостаточно понимаете C++.
• Поскольку вам разрешено использовать инструменты C++, о которых вы узнали с самого начала, вы не можете использовать какую-либо внешнюю библиотеку. И прежде чем вы спросите, это также означает, что нет C++11 и производных, ни Boost, ни чего-то еще, без чего ваш потрясающе опытный друг сказал вам, что C++ не может существовать.
• От вас может потребоваться сдать значительное количество классов. Это может показаться утомительным, если вы не можете написать сценарий своего любимого текстового редактора.
• Прочитайте каждое упражнение полностью, прежде чем начать его! Действительно сделать это.
• The compiler to use is clang++.
• Your code has to be compiled with the following flags : -Wall -Wextra -Werror.
• Каждый из ваших включений должен быть способен включаться независимо от других. Обязательные содержит все остальные входят они в зависимости от того, очевидно.
• На случай, если вам интересно, никакой стиль кодирования не применяется во время работы в C++. Вы можете использовать любой стиль, который вам нравится, без ограничений. Но помните, что код, который ваш эксперт не может прочитать,-это код, который он или она не могут оценить.
• Теперь важный момент : Вы не будете оцениваться программой, если только это не будет прямо указано в предмете. Поэтому вам предоставляется определенная свобода в том, как вы решите выполнять упражнения. Однако помните об ограничениях каждого упражнения, и не ленитесь, вы упустите многое из того, что они могут предложить !
• Это не проблема иметь некоторые посторонние файлы в том, что вы включаете, вы можете выбрать, чтобы разделить ваш код в большем количестве файлов, чем то, что от вас требуется. Не стесняйтесь, так как до тех пор, пока результат не будет оценен программой.
• Даже если тема упражнения коротка, стоит потратить на нее некоторое время, чтобы быть абсолютно уверенным, что вы понимаете, чего от вас ждут, и что вы сделали это наилучшим образом.
____________________________________________________________________________________________________________________________
Exercise 00: Polymorphism, or "When the sorcerer thinks you’d becuter as a sheep"

Turn-in directory :ex00/
Files to turn in : Sorcerer.hpp, Sorcerer.cpp, Victim.hpp, Victim.cpp,Peon.hpp, Peon.cpp, main.cpp
Forbidden functions : None

Полиморфизм - это античная традиция, восходящая ко временам магов, колдунов и прочих шарлатанов. Мы можем попытаться заставить вас думать, что мы подумали об этом первыми, но это ложь!

Давайте поинтересуемся нашим другом Ro/b/ert, великолепным чародеем по профессии.

У Robert есть интересное времяпрепровождение: превращение всего, что он может достать, в овец, пони, выдр и многих других невероятных вещей (когда-либо видел perifalk...?).

Давайте начнем с создания класса Sorcerer, у которого есть имя и титул. У него есть конструктор, принимающий имя и титул колдуна в качестве параметров (в этом порядке).

Класс не может быть создан без параметров (это не имеет никакого смысла!Представьте себе колдуна без имени или титула... Бедняга, он не мог похвастаться перед девицами в таверне...). Но вы все равно должны использовать форму Coplien’s. Опять же, да, здесь есть какой-то трюк. Мы такие хитрые.

При рождении колдуна вы будете демонстрировать:
"NAME, TITLE, is born!"
(Конечно, вы замените имя и титул именем и титулом колдуна, соответственно.)

При его смерти вы будете демонстрировать:
"NAME, TITLE, is dead. Consequences will never be the same!"

Маг должен уметь представляться таким образом:
"I am NAME, TITLE, and I like ponies!"

Он может представиться в любом выходном потоке, благодаря перегрузке оператора << to ostream (вы знаете, как это сделать!).
(Напоминание: использование friend запрещено. Добавьте каждый геттер, который вам нужен!)

Нашему колдуну теперь нужны жертвы, чтобы развлекаться по утрам между медвежьими когтями и соком троллей.

Поэтому вы создадите класс Victim. Немного похожий на волшебника, он будет иметь имя и конструктор, принимающий его имя в качестве параметра.

При рождении жертвы, дисплей:
"Some random victim called NAME just appeared!"

При его смерти, дисплей:
"Victim NAME just died for no apparent reason!"

Жертва тоже может представиться, точно так же, как и колдун, и сказать:
"I'm NAME and I like otters!"

Наша жертва может быть "полиморфизирована" колдуном. Добавьте метод "void getPolymorphed()const" к жертве, который будет говорить:
"NAME has been turned into a cute little sheep!"

Также добавьте функцию-член "void polymorph(Victim const &) const" к вашему колдуну, чтобы вы могли полиморфизировать людей.

Теперь, чтобы добавить немного разнообразия, наш колдун хотел бы полиморфировать что-то еще,а не только общую жертву. Не проблема, вы просто создадите еще несколько!

Make a Peon class. A Peon is a Victim.  So...

При рождении он скажет: "Zog zog." и при его смерти, "Bleuark.."(Совет: Смотрите пример. Все не так просто...) Peon будет полиморфизирован таким образом:
"NAME has been turned into a pink pony!"

(Это что-то вроде пониморфа...)
Следующий код должен быть скомпилирован и отображать следующие выходные данные:

int main()
{
	Sorcerer robert("Robert", "the Magnificent");
	Victim jim("Jimmy");
	Peon joe("Joe");
	std::cout << robert << jim << joe;
	robert.polymorph(jim);
	robert.polymorph(joe);
	return 0;
}

$> clang++ -W -Wall -Werror *.cpp
$> ./a.out | cat -e
Robert, the Magnificent, is born!$
Some random victim called Jimmy just appeared!$
Some random victim called Joe just appeared!$
Zog zog.$
I am Robert, the Magnificent, and I like ponies!$
I'm Jimmy and I like otters!$
I'm Joe and I like otters!$
Jimmy has been turned into a cute little sheep!$
Joe has been turned into a pink pony!$
Bleuark...$
Victim Joe just died for no apparent reason!$
Victim Jimmy just died for no apparent reason!$
Robert, the Magnificent, is dead. Consequences will never be the same!$
$>

Если вы действительно тщательны, вы можете сделать еще несколько тестов: добавить производные классы и т. д...(Нет, на самом деле это не предложение, вы действительно должны это сделать.)
Конечно, как обычно, вы включите свою функцию, потому что все, что не протестировано, не будет оценено.
____________________________________________________________________________________________________________________________

