Глава I
Общий порядок
• Любая функция, реализованная в заголовке (за исключением шаблонов), и любой незащищенный заголовок означают 0 для упражнения.
• Каждый вывод переходит в стандартный вывод и заканчивается новой строкой, если не указано иное.
• За введенными именами файлов необходимо следовать до буквы, а также за именами классов, функций и методов.
• Помните: теперь вы кодируете на C++, а не на C больше. Следовательно:
    ◦ Следующие функции запрещены, и их использование будет наказано 0, без вопросов: *alloc, *printf и free.
    ◦ Вы можете использовать практически все, что есть в стандартной библиотеке. Однако было бы разумно попробовать использовать C++-версии функций, к которым вы привыкли в C, вместо того чтобы просто придерживаться того, что вы знаете, в конце концов, это новый язык. И нет, вам не разрешается использовать STL, пока вы на самом деле не должны это делать (то есть до модуля 08). Это означает, что нет векторов/списков/карт/и т. д... или все, что требует включения <алгоритма> до тех пор.
• На самом деле, использование любой явно запрещенной функции или механики будет наказываться 0, никаких вопросов не задавалось.
• Также обратите внимание, что если не указано иное, ключевые слова C++ "using namespace" и "friend" запрещены. Их использование будет наказано а-42, никаких вопросов.
• Файлы, связанные с классом, всегда будут иметь значение "ClassName.hpp" и "ClassName.cpp", если не указано иное.
• Turn-in directories are ex00/, ex01/, . . . , exn/.
• Вы должны внимательно прочитать примеры. Они могут содержать требования, которые не очевидны в описании упражнения. Если что-то кажется двусмысленным, вы недостаточно понимаете C++.
• Поскольку вам разрешено использовать инструменты C++, о которых вы узнали с самого начала, вы не можете использовать какую-либо внешнюю библиотеку. И прежде чем вы спросите, это также означает, что нет C++11 и производных, ни Boost, ни чего-то еще, без чего ваш потрясающе опытный друг сказал вам, что C++ не может существовать.
• От вас может потребоваться сдать значительное количество классов. Это может показаться утомительным, если вы не можете написать сценарий своего любимого текстового редактора.
• Прочитайте каждое упражнение полностью, прежде чем начать его! Действительно сделать это.
• The compiler to use is clang++.
• Your code has to be compiled with the following flags : -Wall -Wextra -Werror.
• Каждый из ваших включений должен быть способен включаться независимо от других. Обязательные содержит все остальные входят они в зависимости от того, очевидно.
• На случай, если вам интересно, никакой стиль кодирования не применяется во время работы в C++. Вы можете использовать любой стиль, который вам нравится, без ограничений. Но помните, что код, который ваш эксперт не может прочитать,-это код, который он или она не могут оценить.
• Теперь важный момент : Вы не будете оцениваться программой, если только это не будет прямо указано в предмете. Поэтому вам предоставляется определенная свобода в том, как вы решите выполнять упражнения. Однако помните об ограничениях каждого упражнения, и не ленитесь, вы упустите многое из того, что они могут предложить !
• Это не проблема иметь некоторые посторонние файлы в том, что вы включаете, вы можете выбрать, чтобы разделить ваш код в большем количестве файлов, чем то, что от вас требуется. Не стесняйтесь, так как до тех пор, пока результат не будет оценен программой.
• Даже если тема упражнения коротка, стоит потратить на нее некоторое время, чтобы быть абсолютно уверенным, что вы понимаете, чего от вас ждут, и что вы сделали это наилучшим образом.
____________________________________________________________________________________________________________________________
Глава 2

День специальных правил
Вы заметите, что в этой конкретной теме многие проблемы, которые вас просят решить, могут быть решены без использования стандартных контейнеров и без использования стандартных алгоритмов. Тем не менее, их использование-это именно цель, и если вы не приложите все усилия,чтобы использовать стандартные контейнеры и алгоритмы везде, где это уместно, вы получите очень плохую оценку, какой бы функциональной ни была ваша работа. Пожалуйста, не будь таким ленивым.
____________________________________________________________________________________________________________________________
Exercise 00: Easy find

Turn-in directory : ex00/
Files to turn in : easyfind.hpp main.cpp
Forbidden functions : None

Легко начать с правой ноги...
Создайте шаблонную функцию easyfind, шаблонную для типа T, которая принимает T и int.

Предположим, что T-это контейнер int, и найдите первое вхождение второго параметра в первый параметр.

Если он не может быть найден, обработайте ошибку либо с помощью исключения, либо с помощью значения возврата ошибки. Возьмите идеи из того, как работают стандартные контейнеры.
Конечно, вы предоставите основную функцию, которая тщательно ее тестирует.
____________________________________________________________________________________________________________________________
Exercise 01 : Span

Turn-in directory : ex01/
Files to turn in : span.cpp span.hpp main.cpp
Forbidden functions : None

Создайте класс в котором вы можете хранить N int's. N должен быть unsigned int, и должен быть пропущен через конструктор единственным параметром. 

Этот класс будет иметь функцию для хранения одиночного числа (addNumber), которая будет заполнять его. Попытка добавить новый номер, если он уже есть N из них хранящийся в объекте является ошибкой и должен привести к исключению.

Вы создадите две функции, shortestSpan и longestSpan, которые будут находить самый короткий и самый длинный промежуток между всеми числами содержащимися в объекте и вернут его. Если там нет сохраненных чисел или только одно, то нет никакого промежутка, который нужно найти,и вы создадите исключение.

Ниже приведен (слишком короткий) пример теста "main" и связанного с ним вывода. Конечно, ваш "main" будет намного тщательнее, чем этот. Вы должны проверить по крайней мере с числом 10000. Больше было бы хорошо. Было бы также очень хорошо, если бы вы могли добавлять числа, передавая диапазон итераторов, что позволило бы избежать раздражения от выполнения тысяч вызовов к addNumber...

int main()
{
    Span sp = Span(5);
    
    sp.addNumber(5);
    sp.addNumber(3);
    sp.addNumber(17);
    sp.addNumber(9);
    sp.addNumber(11);
    std::cout << sp.shortestSpan() << std::endl;
    std::cout << sp.longestSpan() << std::endl;
}

$> ./ex01
2
14
$>
____________________________________________________________________________________________________________________________
Exercise 02: Mutated abomination

Turn-in directory :ex02/
Files to turn in : mutantstack.cpp mutantstack.hpp main.cpp
Forbidden functions : None

Теперь, когда закуски закончились, давайте сделаем некоторые отвратительные вещи.

std::stack контейнер очень крутой, но это один из многих контейнеров которые не итерируются. Это тоже плохо. но зачем мириться с этим, когда мы можем просто играть в Бога и просто разделывать его, чтобы добавить что-то, что нам нравится?

Вы соедините эту способность в std::stack контейнер, чтобы исправить эту серьезную несправедливость.

Создайте MutantStack класс который будет реализовывать условия std::stack, и предложите все его функции-члены, только он также предложит итератор.

Ниже приведен пример кода, вывод которого должен быть таким же, как если бы мы заменили MutantStack с помощью, например, и std::list. Вы, конечно, предоставите тесты для всего этого в своей основной функции.

int main() 
{
    MutantStack<int>    mstack;

    mstack.push(5);
    mstack.push(17);

    std::cout << mstack.top() << std::endl;

    mstack.pop();

    std::cout << mstack.size() << std::endl;

    mstack.push(3);
    mstack.push(5);
    mstack.push(737);
    //[...]
    mstack.push(0);

    MutantStack<int>::iterator it = mstack.begin();
    MutantStack<int>::iterator ite = mstack.end();

    ++it;

    --it;

    while(it != ite)
    {
        std::cout << *it << std::endl;
        ++it;
    }
    std::stack<int> s(mstack);
    
    return 0;
}
